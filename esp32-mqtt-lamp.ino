#include <Adafruit_NeoPixel.h>
#include <WiFiClientSecure.h>
#include <WiFi.h>
#include <PubSubClient.h>

//ESP32C6 has the LED on GPIO_8
constexpr uint8_t LED_PIN = 8;

// Only one LED (not addressable LED chain)
constexpr uint8_t NUM_LEDS = 1;

// Init RGB helper
Adafruit_NeoPixel rgbLed(NUM_LEDS, LED_PIN);

// Predefined RGB colours
uint8_t COLOR_OFF[]  = {0, 0, 0};
uint8_t COLOR_WHITE[] = {255, 255, 255};

// Flag to track the state of the LED
bool led_on = false;

// MQTT related data
PubSubClient mqttClient;
// MQTT Server IP or Domain
const char *mqtt_server = "127.0.0.1";
// MQTT Port, 1883 is default port for unencrypted traffic while 8883 is the default for encrypted
const uint16_t mqtt_port = 8883;
// Username and password for MQTT broker (optional, depending on the MQTT broker setting)
const char *mqtt_username = "user";
const char *mqtt_password = "user123";
// MQTT client name, only really relevant for MQTT logging
const char *mqtt_client_name = "esp32-c6-lamp";
// MQTT topic to send messages in
const char *mqtt_topic = "home/living_room/lamp/command";

// WiFi related data
WiFiClientSecure wifiClient;
const char *wifi_ssid = "ssid";
const char *wifi_pwd = "password";

// CA cert that was generated and self-signed on the server
const char* server_ca_cert = R"EOF(
-----BEGIN CERTIFICATE-----
MIIDETCCAfmgAwIBAgIUUgf0eV6oHupIIXQGVyCVjYJkxqYwDQYJKoZIhvcNAQEL
BQAwGDEWMBQGA1UEAwwNVHJ1c3RlZENBLm5ldDAeFw0yNTAxMzAyMDI3NDVaFw0y
NjAxMzAyMDI3NDVaMBgxFjAUBgNVBAMMDVRydXN0ZWRDQS5uZXQwggEiMA0GCSqG
SIb3DQEBAQUAA4IBDwAwggEKAoIBAQDHF101FGGaPFdm2NtBc51tkwYOM4hcpvp5
WVhtRVGGijEFNb1fihaNWKjxZrgLUlghCPpIVwCNGx38VLa2EC85n3fEmnQQGuPd
Fm761poXSnlaERKBN3VtGP+yFK6AUmohJB9Ki+Mf2xmX/m9mLugErlcD4yRRwcZH
EezIfhFVt+lRy3Dr4Wvuy8h9VpfCpkka5jaraK8ItRnSSg2hwUxgpSo0+/Xy3Qeb
FdSN6pzYHTSTxV1+R3jyS5Fri447Dr6aEvTkN/w2+A3DVkhUFilyPlVqbKBujDRj
c3Se9lkQmuZW9d1axV0jNSFh+IELG+Zl+MW70PkyysLZ736RkJUBAgMBAAGjUzBR
MB0GA1UdDgQWBBR71u1PmQ7vcEPruw4FKNDjTcLOszAfBgNVHSMEGDAWgBR71u1P
mQ7vcEPruw4FKNDjTcLOszAPBgNVHRMBAf8EBTADAQH/MA0GCSqGSIb3DQEBCwUA
A4IBAQBDO0Vo2MlYHDN4bU95b2f9S4euMj/XF9TzCvMKMdQRGByo0bmBiIRGwCFm
KO8N+Amz2NqgZ7tcFpFCD5iGHer853D1NbFsWN8LnwUbSLTC+TayaHAG8YAOpVS6
eWr/DgtyyfihyUwL3q7v+ZxwIbRBEZ0H8R/m+yJxnwUyHB+r/onnTQsUhk0jM1mJ
koCG8Ygg1IdsjjqqiHdxJ4XQgL+532zzKozq6rNVi7eeoWJM1PTImWW9y8Jbj8hg
J9xARxultAtPx6O8GhV4/UA1tlonXoS1G8GH9ZrcphW+sxIBwf9Nwavsp6KZZ6fE
+ykcpXRaYmLmeEhbunpyME1VSV+r
-----END CERTIFICATE-----
)EOF";

// The client CA certificate and private key is also generated by the server but is used by the client for verification
const char* client_ca_cert = R"EOF(
-----BEGIN CERTIFICATE-----
MIICszCCAZsCFBlnbd1uQ2s1isLGJIasMALJdyywMA0GCSqGSIb3DQEBCwUAMBgx
FjAUBgNVBAMMDVRydXN0ZWRDQS5uZXQwHhcNMjUwMTMwMjEwODI0WhcNMjYwMTMw
MjEwODI0WjAUMRIwEAYDVQQDDAlsb2NhbGhvc3QwggEiMA0GCSqGSIb3DQEBAQUA
A4IBDwAwggEKAoIBAQC/kPD5LxsJXtxr3BLDXwd29ilH0n1pi7XRK/dTp2zgkmDF
TGDEaqEo61Z49UzkzZ9dWXP2nyhE2UjwVe99wPotQn3Aweyfxok4Wql3yPeqe849
IRn6eS9hNCuVRIjbC8C10WX49eY5YpWVQns+RM1cw7q4yCAqokgsZipagBetlmSa
XzDlzExK7rBdE/e+y4260YyR0FkIvJvNCUg691pl2TA2RtG/0vx9Z7ZSypViJtRu
ECFEsVGI6xVSVPaytHjoRnUzzfhDGkEg4StTQclj37QBC+hVONdZMuSYtCrBOqBt
L1RAHe2YuSza7jXYax7O+5UxlbD8JzsGfjf2U1AfAgMBAAEwDQYJKoZIhvcNAQEL
BQADggEBABH2iGE+uPdELhzwKS9/+jE3o6OiAraN/jURVhngw0FgzEoaqQGq9Z8J
+y4ULGxhDzXwIw7Ob1UBNoGQ+POJZSCwatz0rXVaGNQRhWLBYSV/5DDhfQoy2qBT
eXzAPnZPrA0ulsJE+/8VgwVfdeen4k85Q1oxlIV+xgUQIlYDUa6O4c2rDQvF2NyM
1Q2DMIbxE2h8r0wK2fVbmPrwrA1MBwk6EcjvePguaBWiyncaP6DMOQb/cxrFOOZ8
3XI3p+gYhrgBqYBgXme7xVowfSCKmPckaKbVtLvNPh8gmT/djhkc4IgKA2sCDjtr
Z5wvz5lJFld8/5Ib8OBkaDYhbXyssSw=
-----END CERTIFICATE-----
)EOF";

const char* client_priv_key= R"EOF(
-----BEGIN PRIVATE KEY-----
MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQC/kPD5LxsJXtxr
3BLDXwd29ilH0n1pi7XRK/dTp2zgkmDFTGDEaqEo61Z49UzkzZ9dWXP2nyhE2Ujw
Ve99wPotQn3Aweyfxok4Wql3yPeqe849IRn6eS9hNCuVRIjbC8C10WX49eY5YpWV
Qns+RM1cw7q4yCAqokgsZipagBetlmSaXzDlzExK7rBdE/e+y4260YyR0FkIvJvN
CUg691pl2TA2RtG/0vx9Z7ZSypViJtRuECFEsVGI6xVSVPaytHjoRnUzzfhDGkEg
4StTQclj37QBC+hVONdZMuSYtCrBOqBtL1RAHe2YuSza7jXYax7O+5UxlbD8JzsG
fjf2U1AfAgMBAAECggEACYKmM/jFHHLIYDwNjzcWJWKUxUTYU3d+kBZHfrB+yBD8
ToJum2tS+bd7re2fr6XcFfcghrHhselUca1FtbYkgj+DnSCdISGEiaoWl74zOkeD
NnQaPt3qHqbhMwizMqZWuHzfO+9MfegJcEUoqskhP0wh5pXCfKgp2FDW8XJ1unks
iNjbmOB88WktkIrMKW3I3bJjRbWPiN9WFPQ1eK2YkcZytHXJSKjsGLFVYuj4e9LQ
cM4KG2LgFEKOX28h4KKICOB/kmd4znDU1/gvoK8oSA0C8NRkcpJs9jvhFIHjh6la
AXZrwWcvoK9VBG8IKnX+5amlbxzKkCrBsNdF2zYb4QKBgQDh+U3bWu7ZoBhQuTw7
o+T4A8L0kotnG7mfiD2FvyzgTwmhh4jcW8vI/f4s4H+yB6mgb+03y28f4O0owkk+
R6GVdz6UODFtVT3ds7urYu1bSGsL41NnATRfmY8k9YT6CPjIxCJfFs+798ehMqB/
bC9UTTRVs7itMNsNiH4VjjQpBQKBgQDZBTsIPAzkQr9KSr8BM5xxb6wiJ72jzsK8
u9Wz/8xknHVxwCOq3ASPlgXrTstoa8qbAHWE9pGsZ8TQZS/v1CkudNQaKTJKIipv
MnaK4sQlR0o/ayInRYCyPHUo6kSm32cp9e/H6tIcHIZXThk7Tzv/uRCWfF3LsnTB
4wPzYTNN0wKBgFyMd2ekeXhmCi9dfh7LBCbTm5ABSNjE0SRWbyQM5TtFA6PFV7cw
XWkHJYeJtqLaYo2T6arVRcDfpSHxWIAKZFJL0TRxQ0UNCVZ4mx8ZWC7vnO/0fZ8N
Lj8NLEQtzfV9oS7QrWcWd6P7WiZaDsPBMi0rpYiIH9XG0aBcS49We2RlAoGAKVzo
2nHvlxXttbA3ZXg7yhcZvMzMRUtkLGq0mYEYqNh1Pf/8DFWw/NkAOdAjzrw0uoRE
4dnI/A4vIfUXROOwEa2su2u8rQqEAfuhQmlkLyK+UQYPVWLW26HQRsMX4KJV3FaG
pBjqgPci18MH5hj8+4l/Ut9TVT6nKEkneJy/FYcCgYEAinrcqXfuxV1hAAccDWkV
b6aQCfBXxRAcTL48ujVm9v0AzYi1m3+VG+GCvUw6fj3dPq4RFm89reZmOt2y8Pmn
vjVAlBcCyISUFKlIGBhB55614Ig03gWV73/v/KJsPXgqUWZ/PV+KfLtKJMBuGvKp
UPkMiMD+IBVN0mrX2aJJ8NM=
-----END PRIVATE KEY-----
)EOF";

// This function sets up WiFi related settings (connection, certificates)
void setupWiFi() {
  WiFi.mode(WIFI_STA);
  WiFi.begin(wifi_ssid, wifi_pwd);
  Serial.print("Connecting to WiFi...");
  while (WiFi.status() != WL_CONNECTED) {
    Serial.print(".");
    delay(1000);
  }
  Serial.println("Connected to WiFi");
  wifiClient.setCACert(server_ca_cert);
  wifiClient.setCertificate(client_ca_cert);
  wifiClient.setPrivateKey(client_priv_key);
}

// This function connects to MQTT server
void setupMQTT() {
  mqttClient.setClient(wifiClient);
  mqttClient.setServer(mqtt_server, mqtt_port);
  mqttClient.setCallback(message_callback);
  
  if (mqttClient.connect(mqtt_client_name, mqtt_username, mqtt_password)) {
    Serial.println("Connected to MQTT");
    subscribeToTopic();
  }
  else
  {
    Serial.println("Failed to connect to MQTT server");
    Serial.printf("State: %d", mqttClient.state());
  }
}

// This function readies the LED functionality, it is not required for functionality
void setupLED() {
  rgbLed.begin(); 
  rgbLed.show(); 
}

// Method to change the colour of the LED depending on the colour array
void setColor(uint8_t color[]) {
    rgbLed.setPixelColor(0, color[0], color[1], color[2]);
    rgbLed.show();
}

// This function is called on every new message received.
// We read the message and if it matches "on" or "off", we adjust the colour of the LED light
void message_callback(char* topic, byte* payload, unsigned int length) {
  Serial.printf("Message arrived [%s]", topic);
  String message;
  for (int i=0;i<length;i++) 
  {
  message += (char)payload[i];
  }
  if (message == "on")
  {
    setColor(COLOR_WHITE);
    led_on = true;
  }
  else if (message == "off") 
  {
    setColor(COLOR_OFF);
    led_on = false;
  }
  else 
  {
    Serial.print("Invalid command, ignoring...\n");
  }
}

// This function handles the subscription to the defined topic
void subscribeToTopic()
{
   if (mqttClient.connected())
   {
    mqttClient.subscribe(mqtt_topic);
    Serial.print("Subscribed to topic\n");
   }
   else 
   {
    Serial.print("Not connected to MQTT broker\n");
   }
}

// In case we disconnected from the broker, this function tries to reestablish a connection
void reconnectToBroker() 
{
  while (!mqttClient.connected()) 
  {
    if (mqttClient.connect(mqtt_client_name))
    {
      subscribeToTopic();
    }
  }
}

void setup() {

  Serial.begin(115200);

  setupWiFi();

  setupMQTT();

  setupLED();
}

void loop() {
  if(!mqttClient.connected())
  {
    reconnectToBroker();
  }
  mqttClient.loop();
}
