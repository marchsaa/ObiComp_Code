#include <BLEAdvertisedDevice.h>
#include <BLEDevice.h>
#include <BLEScan.h>
#include <BLEBeacon.h>
#include <Adafruit_NeoPixel.h>
#include <WiFiClientSecure.h>
#include <WiFi.h>
#include <PubSubClient.h>

//ESP32C6 has the LED on GPIO_8
constexpr uint8_t LED_PIN = 8;

// Only one LED (not addressable LED chain)
constexpr uint8_t NUM_LEDS = 1;

// Init RGB helper
Adafruit_NeoPixel rgbLed(NUM_LEDS, LED_PIN);

struct Beacons {
  String name, uuid;
};

// Predefined RGB colours
uint8_t COLOR_OFF[]  = {0, 0, 0};
uint8_t COLOR_WHITE[] = {255, 255, 255}; 

/* Range cutoff, RSSI needs to be at the set value or lower (closer to zero)
 to be "detected". Value is dB.
 With Wi-Fi activated, even being next to it, it reads high values, needs more testing */
const int rangeLimit = -50;

// Duration to scan for in seconds
int scanDuration = 10;

// Beacon to look for
const Beacons beacon = {"MyBeacon", "6b671ad7-5fb8-437b-bf41-8c57bbbc3374"};

// MQTT related data
PubSubClient mqttClient;
// MQTT Server IP or Domain
const char *mqtt_server = "";
// MQTT Port, 1883 is default port for unencrypted traffic while 8883 is the default for encrypted
const uint16_t mqtt_port = 8883;
// Username and password for MQTT broker (optional, depending on the MQTT broker setting)
const char *mqtt_username = "user";
const char *mqtt_password = "user123";
// MQTT client name, only really relevant for MQTT logging
const char *mqtt_client_name = "esp32-c6";
// MQTT topic to send messages in
const char *mqtt_topic = "home/living_room/lamp/command";

// WiFi related data
WiFiClientSecure wifiClient;
const char *wifi_ssid = "ssid";
const char *wifi_pwd = "password";

// Last saved state of the detector, used to avoid spamming MQTT channels
// We assume the device is OFF by default
bool isRemoteDeviceOn = false;

// CA cert that was generated and self-signed on the server
const char* server_ca_cert = R"EOF(
-----BEGIN CERTIFICATE-----
MIIDETCCAfmgAwIBAgIUUgf0eV6oHupIIXQGVyCVjYJkxqYwDQYJKoZIhvcNAQEL
BQAwGDEWMBQGA1UEAwwNVHJ1c3RlZENBLm5ldDAeFw0yNTAxMzAyMDI3NDVaFw0y
NjAxMzAyMDI3NDVaMBgxFjAUBgNVBAMMDVRydXN0ZWRDQS5uZXQwggEiMA0GCSqG
SIb3DQEBAQUAA4IBDwAwggEKAoIBAQDHF101FGGaPFdm2NtBc51tkwYOM4hcpvp5
WVhtRVGGijEFNb1fihaNWKjxZrgLUlghCPpIVwCNGx38VLa2EC85n3fEmnQQGuPd
Fm761poXSnlaERKBN3VtGP+yFK6AUmohJB9Ki+Mf2xmX/m9mLugErlcD4yRRwcZH
EezIfhFVt+lRy3Dr4Wvuy8h9VpfCpkka5jaraK8ItRnSSg2hwUxgpSo0+/Xy3Qeb
FdSN6pzYHTSTxV1+R3jyS5Fri447Dr6aEvTkN/w2+A3DVkhUFilyPlVqbKBujDRj
c3Se9lkQmuZW9d1axV0jNSFh+IELG+Zl+MW70PkyysLZ736RkJUBAgMBAAGjUzBR
MB0GA1UdDgQWBBR71u1PmQ7vcEPruw4FKNDjTcLOszAfBgNVHSMEGDAWgBR71u1P
mQ7vcEPruw4FKNDjTcLOszAPBgNVHRMBAf8EBTADAQH/MA0GCSqGSIb3DQEBCwUA
A4IBAQBDO0Vo2MlYHDN4bU95b2f9S4euMj/XF9TzCvMKMdQRGByo0bmBiIRGwCFm
KO8N+Amz2NqgZ7tcFpFCD5iGHer853D1NbFsWN8LnwUbSLTC+TayaHAG8YAOpVS6
eWr/DgtyyfihyUwL3q7v+ZxwIbRBEZ0H8R/m+yJxnwUyHB+r/onnTQsUhk0jM1mJ
koCG8Ygg1IdsjjqqiHdxJ4XQgL+532zzKozq6rNVi7eeoWJM1PTImWW9y8Jbj8hg
J9xARxultAtPx6O8GhV4/UA1tlonXoS1G8GH9ZrcphW+sxIBwf9Nwavsp6KZZ6fE
+ykcpXRaYmLmeEhbunpyME1VSV+r
-----END CERTIFICATE-----
)EOF";

// The client CA certificate and private key is also generated by the server but is used by the client for verification
const char* client_ca_cert = R"EOF(
-----BEGIN CERTIFICATE-----
MIICszCCAZsCFBlnbd1uQ2s1isLGJIasMALJdyywMA0GCSqGSIb3DQEBCwUAMBgx
FjAUBgNVBAMMDVRydXN0ZWRDQS5uZXQwHhcNMjUwMTMwMjEwODI0WhcNMjYwMTMw
MjEwODI0WjAUMRIwEAYDVQQDDAlsb2NhbGhvc3QwggEiMA0GCSqGSIb3DQEBAQUA
A4IBDwAwggEKAoIBAQC/kPD5LxsJXtxr3BLDXwd29ilH0n1pi7XRK/dTp2zgkmDF
TGDEaqEo61Z49UzkzZ9dWXP2nyhE2UjwVe99wPotQn3Aweyfxok4Wql3yPeqe849
IRn6eS9hNCuVRIjbC8C10WX49eY5YpWVQns+RM1cw7q4yCAqokgsZipagBetlmSa
XzDlzExK7rBdE/e+y4260YyR0FkIvJvNCUg691pl2TA2RtG/0vx9Z7ZSypViJtRu
ECFEsVGI6xVSVPaytHjoRnUzzfhDGkEg4StTQclj37QBC+hVONdZMuSYtCrBOqBt
L1RAHe2YuSza7jXYax7O+5UxlbD8JzsGfjf2U1AfAgMBAAEwDQYJKoZIhvcNAQEL
BQADggEBABH2iGE+uPdELhzwKS9/+jE3o6OiAraN/jURVhngw0FgzEoaqQGq9Z8J
+y4ULGxhDzXwIw7Ob1UBNoGQ+POJZSCwatz0rXVaGNQRhWLBYSV/5DDhfQoy2qBT
eXzAPnZPrA0ulsJE+/8VgwVfdeen4k85Q1oxlIV+xgUQIlYDUa6O4c2rDQvF2NyM
1Q2DMIbxE2h8r0wK2fVbmPrwrA1MBwk6EcjvePguaBWiyncaP6DMOQb/cxrFOOZ8
3XI3p+gYhrgBqYBgXme7xVowfSCKmPckaKbVtLvNPh8gmT/djhkc4IgKA2sCDjtr
Z5wvz5lJFld8/5Ib8OBkaDYhbXyssSw=
-----END CERTIFICATE-----
)EOF";

const char* client_priv_key= R"EOF(
-----BEGIN PRIVATE KEY-----
MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQC/kPD5LxsJXtxr
3BLDXwd29ilH0n1pi7XRK/dTp2zgkmDFTGDEaqEo61Z49UzkzZ9dWXP2nyhE2Ujw
Ve99wPotQn3Aweyfxok4Wql3yPeqe849IRn6eS9hNCuVRIjbC8C10WX49eY5YpWV
Qns+RM1cw7q4yCAqokgsZipagBetlmSaXzDlzExK7rBdE/e+y4260YyR0FkIvJvN
CUg691pl2TA2RtG/0vx9Z7ZSypViJtRuECFEsVGI6xVSVPaytHjoRnUzzfhDGkEg
4StTQclj37QBC+hVONdZMuSYtCrBOqBtL1RAHe2YuSza7jXYax7O+5UxlbD8JzsG
fjf2U1AfAgMBAAECggEACYKmM/jFHHLIYDwNjzcWJWKUxUTYU3d+kBZHfrB+yBD8
ToJum2tS+bd7re2fr6XcFfcghrHhselUca1FtbYkgj+DnSCdISGEiaoWl74zOkeD
NnQaPt3qHqbhMwizMqZWuHzfO+9MfegJcEUoqskhP0wh5pXCfKgp2FDW8XJ1unks
iNjbmOB88WktkIrMKW3I3bJjRbWPiN9WFPQ1eK2YkcZytHXJSKjsGLFVYuj4e9LQ
cM4KG2LgFEKOX28h4KKICOB/kmd4znDU1/gvoK8oSA0C8NRkcpJs9jvhFIHjh6la
AXZrwWcvoK9VBG8IKnX+5amlbxzKkCrBsNdF2zYb4QKBgQDh+U3bWu7ZoBhQuTw7
o+T4A8L0kotnG7mfiD2FvyzgTwmhh4jcW8vI/f4s4H+yB6mgb+03y28f4O0owkk+
R6GVdz6UODFtVT3ds7urYu1bSGsL41NnATRfmY8k9YT6CPjIxCJfFs+798ehMqB/
bC9UTTRVs7itMNsNiH4VjjQpBQKBgQDZBTsIPAzkQr9KSr8BM5xxb6wiJ72jzsK8
u9Wz/8xknHVxwCOq3ASPlgXrTstoa8qbAHWE9pGsZ8TQZS/v1CkudNQaKTJKIipv
MnaK4sQlR0o/ayInRYCyPHUo6kSm32cp9e/H6tIcHIZXThk7Tzv/uRCWfF3LsnTB
4wPzYTNN0wKBgFyMd2ekeXhmCi9dfh7LBCbTm5ABSNjE0SRWbyQM5TtFA6PFV7cw
XWkHJYeJtqLaYo2T6arVRcDfpSHxWIAKZFJL0TRxQ0UNCVZ4mx8ZWC7vnO/0fZ8N
Lj8NLEQtzfV9oS7QrWcWd6P7WiZaDsPBMi0rpYiIH9XG0aBcS49We2RlAoGAKVzo
2nHvlxXttbA3ZXg7yhcZvMzMRUtkLGq0mYEYqNh1Pf/8DFWw/NkAOdAjzrw0uoRE
4dnI/A4vIfUXROOwEa2su2u8rQqEAfuhQmlkLyK+UQYPVWLW26HQRsMX4KJV3FaG
pBjqgPci18MH5hj8+4l/Ut9TVT6nKEkneJy/FYcCgYEAinrcqXfuxV1hAAccDWkV
b6aQCfBXxRAcTL48ujVm9v0AzYi1m3+VG+GCvUw6fj3dPq4RFm89reZmOt2y8Pmn
vjVAlBcCyISUFKlIGBhB55614Ig03gWV73/v/KJsPXgqUWZ/PV+KfLtKJMBuGvKp
UPkMiMD+IBVN0mrX2aJJ8NM=
-----END PRIVATE KEY-----
)EOF";

// This function sets up WiFi related settings (connection, certificates)
void setupWiFi() {
  WiFi.mode(WIFI_STA);
  WiFi.begin(wifi_ssid, wifi_pwd);
  Serial.print("Connecting to WiFi...");
  while (WiFi.status() != WL_CONNECTED) {
    Serial.print(".");
    delay(1000);
  }
  Serial.println("Connected to WiFi");
  wifiClient.setCACert(server_ca_cert);
  wifiClient.setCertificate(client_ca_cert);
  wifiClient.setPrivateKey(client_priv_key);
}

// This function connects to MQTT server
void setupMQTT() {
  mqttClient.setClient(wifiClient);
  mqttClient.setServer(mqtt_server, mqtt_port);
  if (mqttClient.connect(mqtt_client_name, mqtt_username, mqtt_password)) {
    Serial.println("Connected to MQTT");
  }
  else
  {
    Serial.println("Failed to connect to MQTT server");
    Serial.printf("State: %d", mqttClient.state());
  }
}

// This function readies the LED functionality, it is not required for functionality
void setupLED() {
  rgbLed.begin(); 
  rgbLed.show(); 
}

// Method to change the colour of the LED depending on the passed color array
void setColor(uint8_t color[]) {
    rgbLed.setPixelColor(0, color[0], color[1], color[2]);
    rgbLed.show();
}

// Scans for BLE devices and returns the results
BLEScanResults* scanBluetooth(int duration) {
  BLEScan *scan = BLEDevice::getScan();
  scan->setActiveScan(true);
  return scan->start(duration);
}

/* Setup method, initializes RGB, serial output and starts BLE scanner */
void setup() {
  
  Serial.begin(115200);

  setupWiFi();

  setupMQTT();

  setupLED();

  BLEDevice::init("");
}

void loop() {
  // Scan for 10 seconds
  BLEScanResults* results = scanBluetooth(scanDuration);

  // Beacon not matched yet
  bool beaconMatched = false;

  // Iterate through the scanned results and look for the beacon
  for (int i = 0; i < results->getCount(); i++) 
  {
    // As our beacon has a name AND a service UUID, ignore devices that dont have either
    if (!results->getDevice(i).haveName() && !results->getDevice(i).haveServiceUUID()) continue;

    String deviceName = results->getDevice(i).getName();
    String deviceUUID = results->getDevice(i).getServiceUUID().toString();

    // If both the name and the service UUID match, check if the device is within the range limit
    if (deviceName.equalsIgnoreCase(beacon.name) && deviceUUID.equalsIgnoreCase(beacon.uuid))
    {
      int rssi = results->getDevice(i).getRSSI();
      beaconMatched = true;

      // Device within range, send ON message to the MQTT channel
      if ( rssi > rangeLimit) {
        Serial.printf("Beacon nearby! RSSI is %d\n", rssi);
        setColor(COLOR_WHITE);

        // To avoid sending ON every scan, check if the device has been enabled before. 
        // Only send ON if the device is off
        if (!isRemoteDeviceOn)
        {
          if (mqttClient.publish(mqtt_topic, "on")) 
          {
            Serial.println("Message ON published");
            isRemoteDeviceOn = true;
          }
        }
      // Device has been found but its not within range, therefore turn device off if it was on
      } else {
        Serial.printf("Beacon nearby but not near enough, RSSI is %d", rssi);
        setColor(COLOR_OFF);
        if (isRemoteDeviceOn)
        {
          if(mqttClient.publish(mqtt_topic, "off"))
          {
            Serial.println("Messaged OFF published!");
            isRemoteDeviceOn = false;
          }
        }          
      }
    }
  }
  // If no beacon was found, send OFF message
  if(!beaconMatched)
  {
    mqttClient.publish(mqtt_topic, "off");
    isRemoteDeviceOn = false;
    setColor(COLOR_OFF);
  }
  // This function does some important backwork, including KEEPALIVE 
  // so the connection to the MQTT server doesn't timeout
  mqttClient.loop();
}